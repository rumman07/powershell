> $PSVersionTable  #Give the version of the powershell currently running

#Switching between powershell versions
> powershell -version 3.0  #changes the powershell version to 3.0 
> $PSVersionTable  #to check the current version of powershell runnung
> Start-Process Powershell -verb runas   # to start powershell as administrator from the commandline 

##Three steps before using Powershell
> Update-Help  #Updates the powershell makes sure you have the latest and greates version 
> Update-Help -Verbose -Force -ErrorAction SilentlyContinue 
##Enable Powershell script execution. As a security precaution the ability to execute powershell script is disabled by default 
> Get-ExecutionPolicy
> Set-ExecutionPolicy RemoteSigned   #Setting the execution policy

##On each computer that you want remote commands to be executed on, run the following Powershell command except WS 2012 its set by default
> Enable-PSRemoting

##A Powershell profile is a text file that is automatically loaded everytime powershell is started. Powershell profiles are used to
##persist certain customization like -Aliases, -Functions, -Variables. You dont actually have a Powershell profile untill you create one
##To create a Powershell profile create a text file with the specified name and in the specified location based on the type of profile
##you want to use. There are 4 types of profile in Powershell -AllUsersAllHosts: Applies to all users and all shells located@%windir%\
##System32\WindowsPowerShell\v1.0\profile.ps1  -AllUsersCurrentHost: Applies to all users, but only the Microsoft.Powershell shell
##located@%windir%\System32\WindowsPowerShell\v1.0\Microsoft.PowerShell_profile.ps1  -CurrentUserAllHosts: Applies only to the current user, but all
##shells located@%UserProfile%\My Documents\WindowsPowerShell\profile.ps1  -CurrentUserCurrentHost: Applies only to the current user and the
##Microsoft.Powershell shell located@%UserProfile%\My Documents\WindowsPowerShell\Microsoft.PowerShell_profile.ps1 

> $Profile  # built in variable dispalys the profile location but the path and the profile do not exists there until you create them
> Test-Path $Profile  # tells you if you have a profile established
> New-Item -path $profile -type file -force  # to create a profile 

##Cmdlet are commands in the Powershell environment
##Cmdlets perform an action and typically return a Microsoft .Net Framework object to the next command in the pipeline
##Cmdlets are designed to have similar structure and syntax: Verb-Noun -parameter arguement 
##The verb describes the action that is to take place
##The noun describes the target of that action 
##The parameter is an optional characteristic or property of the noun 
##Powershell parameter is always preceded by a hyphen (-)
##The arguement is a value that can be provided for a parameter 

##There are six common cmdlet verbs
##Get     #Queries a specific object
##Set     #Modifies the settings of an object
##Enable  #Enables a settings
##Disable #Disables a setting 
##New     #Creates a new instance of an item 
##Remove  #Removes an instance of an item 
##There are many other verbs  Add, Clear, Export, Format, Import, Invoke, etc
##Anything in the [] is optional 
> Get-Process [[-name] string[]] [-ComponentName string[]] [-File VersionInfo] [-Module] [CommonParameters]
> Get-Process -name powerpnt 
> Get-Process   #returns a list of all the processes running in the system 
> Get-Help 
> Get-Help Get-Process 
> Get-ChildItem -force    #To view the hidden files and system files 
> Get-Help <cmdlet>  ## to display information on one page
> Help <cmdlet>

##<cmdlet> -?  # displays information on multiple pages

> Get-Help <cmdlet> -examples  # to see example of the command
> Get-Help <cmdlet> -detailed  # For more information 
> Get-Help <cmdlet> -full 
> Get-Help <cmdlet> -ShowWindow
> Get-Help <cmdlet> -online
> Get-Command   # returns a list of the the commands in the version you are running 
> Get-Command | more   # gives information page by page by hitting the space key
> Get-Command -type cmdlet   #returns a list of only cmdlets

> Format-Wide     #Displays only the default property of an object by default
> Format-List     #Displays an object in the form of a listing, with each property labeled and displayed on a sepaerate line 
> Format-Table    #Produces a tabular layout
> Format-Custom   #Formats the output of a command as defined in an alternative view

> Get-Process | Format-Wide 
> Get-Process | Format-Wide -column 6
> Get-Process | Format-List
> Get-Process -name powershell | Format-List -Property ProcessName,FileVersion,StartTime,Id
> Get-Process -name powershell | Format-List -Property *
> Get-Process -name powershell | Format-Table
> Get-Process -name powershell | Format-Table -Property Path,Name,Id,Company -Autosize
> Get-Process -name powershell | Format-Table -Wrap -Property Name,Id,Company,Path  
> Get-Process -name powershell | Format-Table -Wrap -Autosize -Property Name,Id,Path -GroupBy Company 

##The Get-Member cmdlet retrives information about .Net objects. It displays the properties and methods of the object. The members of the object
> $m | Get-Member 
> $m | Get-Member -membertype methods 

> Get-ChildItem  ## Gets the files and folders in a file system drive.  Aliases ls,dir,gci
> Get-ChildItem -recurse  ## Gets the files and folders in a file system drive recursively
> gci c:\*.* -include *.txt ## Searches all the locations and returns only text files 
> Get-ChildItem | Sort-Object  ## Retrieves child items in the location. Pipes the item to the next cmdlet. Sorts objects by the name property by default  

## $_ is an object that is populated with the current item thats in the pipeline 

> Get-Service | Where-Object {$_.DisplayName -Match "MS"} 

## To run a script make sure Execution Policy is set to RemoteSigned and type the path and name of the script file. The path is required even
## the script is located in the current directory. This is a deliberate security measure from MIcrosoft to make it more difficult for malicious 
## code to run scripts and also to make it more difficult to inadvertently execute a script

> Start-Sleep <TimeInSec>

## Launching a powershell script from desktop shortcut
## 1) Create a shortcut 2) Right click the shortcut and choose properties 3) Click on the shortcut tab 4) In the target field enter:
## %SystemRoot%\system32\WindowsPowerShell\v1.0\powershell.exe -ExecutionPolicy Bypass -File "C:\path\to\powershellScript.ps1"

## If the variable contains spaces it must be enclosed in braces {}. Example: ${Variable Name} 
## Powershell will determine the data-type of the variable for you and it may change it as well
## We can explicitly set variables to a specific data type. Powershell will not change explicitly set data types. Examples: [int]$ml=7
## [System.Int32]$a=4, [datetime], [string], [char], [double], [int], [boolean] 

> $serverIP='10.10.10.10'
> Set-Variable serverIP -option Readonly  # this sets the value of the variable to the desired value so that no one can change it
> Set-Variable serverIP -option none -force  # this undoes the Readonly option
> Remove-Variable variableName -force 

## A constant is a write protected variable. Once the value is set it cannot be easily changed. The New-Variable cmdlet is used to create constant in Powershell
> Set-Variable variableName -option Constant -value '12.12.12.12'  #to create a constant

## Comparison operators: -eq -lt -gt, -ge, -le, -ne    # These operators can be used to compare strings
## -ieq  # To perform case-insensitive comparisons and is the default
## -ceq  # To perform case sensitive comparisons
## Logical operators: -not ! -and -or 

#######IF Statement#######################
> $day = Get-Date
> If (day.day -eq 12)
  {
     Write-Host "Today"
  }
  else
  {
    Write-Host "Not Today"
  }
############Syntax:
> If (condition) {run this code block}

#Syntax ElseIf:
> If (condition) {run this code block}
> ElseIf (condition) {run this code block}
> You cam add more elseif to test the condition
>

############Syntax: ElseIf
> If (condition) {run this code block}
> ElseIf (condition) {run this code block}
>
>
> Else {run this code block} 

#Looping is a basic programming process that allows us to execute the same command multiple times 
#For Each-Object : Loops through a collection of objects
#For : Executes a specific number of times 
#While : Executes as long as a condition remains true; tests the condition first
#Do While : Executes once then tests the condition then repeats as long as the condition remains true 
#Do Until : Executes once and repeats until a condition is true

########Syntax For Loops
> $a=5,6,7,8,9
> $a | ForEach {write-host $_}

> ForEach ($value in $a)
> {write-host $value}

> $a="Mark","Bob","Jane"
> ForEach ($value in $a)
> {write-host $value} 

> $a | ForEacH {write-host $_} 

> For ($a; $a -le 5; $a++) {write-host $a}

#Do While Loop
> $a=1
> Do {write-host $a; $a++} 
> While ($a -lt 5}

> $b=1
> Do {write-host $b; $b++}
> Until ($b -gt 5)


###Regex. Regular expression is a pattern that is used to locate matching data
###Regular expression cam match data using two methods : -Literal Matches -Pattern Matches 

#Syntax : Literal Match
> "Microsoft" -match "soft"
> "Software" -cmatch "soft"   #This will return False since its a case sensitive match  

#Pattern match is based on regular expression character:
# . (period) matches a single character 
#[aeiou] matches at least one character specified within the brackets
#[b-f] matches at least one character specified within the range 
#[^bcdef] matches any character except those within the brackets 
#^ matches characters located at the begining of a string 
#$ matches characters located at the end of a string 
#* matches zero or more occurances of the preceeding character
#? matches zero or one occurance of the preceeding character 
#\ matches the character following the escape (\) character 

#Regular Expression qualifiers : 
#* must match zero or more times
#+ must match one or more times 
#? must match no more tha one time 
#{n} must match n times 
#{n,} must atleast n matches 
#{n,m} must match atleast n times, but no more than m times 

#Regular Expression shortcuts : 
#\d matches any decimal digit, same as [0-9]
#\w matches any word character, same as [0-9A-Za-z] 
#\D matches any non digit 
#\W matches any non-word charcter such as space  
#\S matches any non whitespace character 

> Get-Help about_regular_expression

#Regex match ipaddress 
> $ip="192.168.120.15"
> $rx="\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}"
> $ip -match $rx 

#Regex match SSN
> $ssn="111-23-5678"
> $rxssn="^\d{3}-\d{2}-\d{4}$"
> $ssn -match $rxssn 

#Escape character in powershell `
> Write-Host `n`n`n`n`t`t`t"Hello"`n`n`n`n`n (grave accent)

#Different implementation of the escape character 
> ` at the end of a command line to continue the command on the next line 
> `$ to include a $ in the output
> `0 means NULL ($null is preffered)
> `a makes an alert sound 
> `b means backspace
> `f means formfeed (only affects printed documents)
> `n means new line 
> `r means carriage return
> `t means horizontal tab
> `v means vertical tab (only affects printed document) 
> `' means single quote
> `" means double quote

#The # is the single line comment symbol in Powershell 

#Parameters allow us to provide the script with additional information
#Parameters are easily added to script using the param block
#There are two forms :
#Simple form: 
> Param([string]$variableName)
#Full form: 
> Param(
  [Parameter(Mandatory=$true)]
  [string]$variableName)  

> Param(
[Parameter(Mandatory=$true)]
[string]$Path,

[Parameter(Mandatory=$true)]
[string]$LastWrite 
)   
  
  
####What is a Provider?
#A Windows Powershell provider allows any data store to be exposed like a file system as if it were a mounted drive. A .Net assembly that exposes the data 
#in a simplified more familiar structure. Simplifies accessing external data outside the PowerShell environment. Powershell providers are the 
#Powershell version of the system drives. Providers are often reffered to as PSDrives. We actually connect to a provider via PSDrives. Most providers 
#have only one PSDrive. The FileSystem provider has as many PSDrives as there are drives on the system. The Registry provider has two PSDrives (HKLM and HKCU)
#You can create a custom PSDrive to serve as a shortcut to a system resource. PSDrives are a result of the functionalities of Powershell providers 
#Available Powershell providers : Alias; Environment; FileSystem; Function; Registry; Variable; Certificate; WSMan (Web Services Management configuration information)

> Get-PSProvider    #Lists all the available Providers
> Get-PSDrive       #Lists all the PSDrives that are available in the current Provider environment
> Set-Location Alias:  #To mount a PSDrive to access the Alias provider. To get to a provider the colon at the end of the provider name is very important
> dir   #To list all the Aliases on the machine
> New-PSDrive -name <nameofprovider> -PSProvider FileSystem -Root (resolve-path ~/*documents) 
> Set-Location nameofprovider: 
> dir 
###Once you move to a PSDrive provided by one of the providers you utilize the same Powershell commands and their parameters to perform familiar tasks
###The FileSystem Provider is accessed when the Powershell is launched and is the by default. Allows to create, retrive, and remove files and folders 
###Part of the data provided by the FileSystem provider is the mode column 

> Set-Location Alias:
> New-Alias <aliaName> <cmdlet>   # To create a new alias for the cmdlet 

###The Variable Provider shows us which Powershell and user defined variables are available. Powershell providers are preceeded by the $ however the
###list of variables in the Variable Provider do not include the $ as the first character add the $ to access the variables in Powershell code and scripts

###Function is a named block of code. You can create your own functions. Powershell has a set of functions built-in 
> Set-Location Function:   #This will access the function provider and mount the Powershell function drive 
> dir 
> Get-Content <function-Name>  #Displays the code running in the background for that function 

###The Environment Provider exposes all the environment variables defined on the system 
> Set-Location Env: 
> gci
> gci <env_variable_name> | Format-List *   #The * will give more information on the Env variable in the Format-List format

> Set-Location HKLM:\Software  #To access the available software registry in HKLM

###The Certificate provider provides access to X.509 certificates stores and certificates 
> Set-Location Cert: 
> gci
> gci -recurse
> gci -path cert:\LocalMachine  
> gci -path cert:\LocalMachine\AuthRoot
> gci -recurse | Export-CSV "C:\MLCerts.csv"
> Invoke-Item "C:\MLCert.csv"        
> Invoke-Item "${pwd}\fileName.extension"   #Using string interpolation to get value from a variable and concatenate with the string following 

#Files and Folders
> GCI -Path "\path\to\folder" -Recurse -Include *.exe | Where-Object -FilterScript {($_.LastWriteTime -gt "2014-01-01")} 
> GCI > <path\to\file>.txt
> New-Item <path\to\file>.txt -type file
> Set-Content <path\to\file>.txt "Type the content here..."
> Add-Content <path\to\file>.txt "Type the content here..."
> GCI | Out-File <path\to\file>.txt 
> Get-Content <path\to\file>.txt 
> $a = Get-Content <path\to\file>.txt
> $a 

#Creating HTML File 
> Get-Service | Where-Object {$_.status -eq "running"}
> Get-Service | Where-Object {$_.status -eq "running"} | ConvertTo-HTML Name, DisplayName, Status | Set-Content <path\to\file>.html           

#Creating and Reading from xml file
> GCI | Export-CliXML <\path\to\file>.xml
> $x = Import-CliXML <\path\to\file>.xml
> $x 

#Write and read data from csv file
> Get-Service | Export-CSV "\path\to\file"
> $s = Import-CSV \path\to\file
> $s
> Invoke-Item \path\to\file

###WMI -Windows Management Instrumentation exposes information on almost every aspect of a Windows Computer i.e. Operating System, Hardware, Software
###Powershell provides two ways of working with WMI : WMI cmdlets and CIM cmdlets 
> Get-WmiObject Win32_bios
> Get-CimInstance Win32_bios
> Get-Wmiobject Win32_processor
> Get-CimInstance Win32_procesor
###OneGet
